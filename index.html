<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Trapped Ion Quantum Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', monospace; }
        
        /* HUD / Control Panel */
        #ui-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            padding: 15px;
            background: rgba(20, 20, 30, 0.8);
            border: 1px solid #444;
            border-radius: 8px;
            color: white;
            z-index: 10;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            border-right: 1px solid #555;
            padding-right: 15px;
        }
        .control-group:last-child { border-right: none; }

        button {
            background: #222;
            color: #00ffcc;
            border: 1px solid #00ffcc;
            padding: 8px 15px;
            margin: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        button:hover { background: #00ffcc; color: #000; }
        button:disabled { border-color: #555; color: #555; cursor: not-allowed; }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffcc;
            pointer-events: none;
        }
    </style>
    <!-- Import Three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- Information Overlay -->
    <div id="info-panel">
        <h1>Trapped Ion Sim</h1>
        <p>Status: <span id="system-status">Idle</span></p>
        <p>Selected Ion: <span id="selected-ion-id">None</span></p>
        <small>Click ions to select them</small>
    </div>

    <!-- Controls -->
    <div id="ui-container">
        <div class="control-group">
            <small>Single Qubit</small>
            <button id="btn-cool" onclick="app.coolIons()">Doppler Cool (Reset)</button>
            <button id="btn-excite" onclick="app.pulseLaser('pi')">π Pulse (X Gate)</button>
            <button id="btn-super" onclick="app.pulseLaser('half-pi')">π/2 Pulse (H Gate)</button>
        </div>
        <div class="control-group">
            <small>Two Qubit</small>
            <button id="btn-entangle" onclick="app.entangleIons()">Entangle (XX Gate)</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        class IonSimulator {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                
                this.ions = []; // Stores ion meshes and state
                this.lasers = []; // Stores active laser beam meshes
                this.selectedIonIndex = -1;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                this.init();
                this.createTrap();
                this.createIons(5); // Create 5 ions
                this.setupPostProcessing();
                this.animate();
            }

            init() {
                // Setup Renderer
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.toneMapping = THREE.ReinhardToneMapping;
                document.body.appendChild(this.renderer.domElement);

                // Camera Positioning
                this.camera.position.set(0, 5, 10);
                
                // Controls
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040);
                this.scene.add(ambientLight);
                const pointLight = new THREE.PointLight(0xffffff, 1);
                pointLight.position.set(5, 5, 5);
                this.scene.add(pointLight);

                // Events
                window.addEventListener('resize', () => this.onWindowResize(), false);
                window.addEventListener('click', (e) => this.onMouseClick(e), false);
            }

            // 1. The Physics Trap Visualization
            createTrap() {
                const electrodeMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffd700, 
                    metalness: 0.8, 
                    roughness: 0.2 
                });
                
                // Create 4 rods (Quadrupole design)
                const rodGeo = new THREE.CylinderGeometry(0.2, 0.2, 12, 32);
                rodGeo.rotateZ(Math.PI / 2); // Lay flat along X

                const positions = [
                    [0, 1.5, 1.5], [0, 1.5, -1.5],
                    [0, -1.5, 1.5], [0, -1.5, -1.5]
                ];

                positions.forEach(pos => {
                    const rod = new THREE.Mesh(rodGeo, electrodeMat);
                    rod.position.set(...pos);
                    this.scene.add(rod);
                });

                // Add faint grid for reference
                const grid = new THREE.GridHelper(20, 20, 0x333333, 0x111111);
                grid.position.y = -3;
                this.scene.add(grid);
            }

            // 2. The Ions
            createIons(count) {
                const geometry = new THREE.SphereGeometry(0.25, 32, 32);
                const spacing = 1.2;
                const startX = -((count - 1) * spacing) / 2;

                for (let i = 0; i < count; i++) {
                    // Material: Blue = Ground State (0), Red = Excited (1)
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x00ffff,
                        emissive: 0x0088ff,
                        emissiveIntensity: 2,
                        toneMapped: false
                    });

                    const ion = new THREE.Mesh(geometry, material);
                    ion.position.set(startX + (i * spacing), 0, 0);
                    
                    // Custom properties for our simulation logic
                    ion.userData = {
                        id: i,
                        state: 0, // 0 to 1
                        isSelected: false,
                        basePosition: ion.position.clone()
                    };

                    this.scene.add(ion);
                    this.ions.push(ion);
                }
            }

            // 3. Rendering Glow (Bloom)
            setupPostProcessing() {
                this.composer = new EffectComposer(this.renderer);
                const renderPass = new RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);

                // The Bloom makes emissive materials glow visually
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0;
                bloomPass.strength = 1.5;
                bloomPass.radius = 0.5;
                this.composer.addPass(bloomPass);
            }

            // --- INTERACTION FUNCTIONS ---

            onMouseClick(event) {
                // Calculate mouse position in normalized device coordinates
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.ions);

                // Deselect all first
                this.ions.forEach(ion => {
                    ion.userData.isSelected = false;
                    ion.scale.set(1,1,1);
                });
                this.selectedIonIndex = -1;
                document.getElementById('selected-ion-id').innerText = "None";

                if (intersects.length > 0) {
                    const hit = intersects[0].object;
                    hit.userData.isSelected = true;
                    hit.scale.set(1.5, 1.5, 1.5); // Visual feedback
                    this.selectedIonIndex = hit.userData.id;
                    document.getElementById('selected-ion-id').innerText = `Ion ${hit.userData.id}`;
                }
            }

            // --- SIMULATION LOGIC ---

            coolIons() {
                document.getElementById('system-status').innerText = "Cooling...";
                this.fireGlobalLaser(0x0000ff);
                
                setTimeout(() => {
                    this.ions.forEach(ion => {
                        ion.userData.state = 0;
                        this.updateIonColor(ion);
                    });
                    document.getElementById('system-status').innerText = "Idle (Ground State)";
                }, 500);
            }

            pulseLaser(type) {
                if (this.selectedIonIndex === -1) {
                    alert("Select an ion first!");
                    return;
                }

                const ion = this.ions[this.selectedIonIndex];
                const color = type === 'pi' ? 0xff0000 : 0xff00ff; // Red or Purple
                
                // Visualize Laser
                this.fireLaserBeam(ion.position, color);

                // Update State (Mock Logic)
                if (type === 'pi') {
                    // Flip state 0 <-> 1
                    ion.userData.state = ion.userData.state === 0 ? 1 : 0;
                } else if (type === 'half-pi') {
                    // Superposition state (visualized as 0.5)
                    ion.userData.state = 0.5;
                }
                
                setTimeout(() => {
                    this.updateIonColor(ion);
                }, 200);
            }

            entangleIons() {
                // Mock: Entangles selected ion with its right neighbor
                if (this.selectedIonIndex === -1 || this.selectedIonIndex >= this.ions.length - 1) {
                    alert("Select an ion (except the last one) to entangle with neighbor.");
                    return;
                }

                const ion1 = this.ions[this.selectedIonIndex];
                const ion2 = this.ions[this.selectedIonIndex + 1];

                // Visualise entanglement beam between them
                this.createEntanglementLink(ion1, ion2);
            }

            updateIonColor(ion) {
                // 0 = Blue, 1 = Red, 0.5 = Purple
                const color = new THREE.Color();
                const blue = new THREE.Color(0x0088ff);
                const red = new THREE.Color(0xff0022);
                
                color.lerpColors(blue, red, ion.userData.state);
                
                ion.material.color.set(color);
                ion.material.emissive.set(color);
            }

            // --- VISUAL EFFECTS ---

            fireLaserBeam(targetPos, colorHex) {
                // Create a cylinder from "outside" to the ion
                const laserSource = new THREE.Vector3(0, 5, 5);
                const dist = laserSource.distanceTo(targetPos);
                
                const geom = new THREE.CylinderGeometry(0.02, 0.02, dist, 8);
                geom.translate(0, dist/2, 0);
                geom.rotateX(Math.PI / 2);
                geom.lookAt(targetPos); // Warning: Geometry rotation tricks needed here usually
                
                // Simple Line approach is often easier for lasers
                const points = [laserSource, targetPos];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: colorHex, linewidth: 2 });
                const line = new THREE.Line(geometry, material);
                
                this.scene.add(line);

                // Remove laser after 200ms
                setTimeout(() => { this.scene.remove(line); }, 200);
            }

            fireGlobalLaser(colorHex) {
                // A wide beam covering everything
                const geometry = new THREE.CylinderGeometry(5, 5, 20, 32);
                geometry.rotateZ(Math.PI/2);
                const material = new THREE.MeshBasicMaterial({ 
                    color: colorHex, 
                    transparent: true, 
                    opacity: 0.1, 
                    side: THREE.DoubleSide 
                });
                const beam = new THREE.Mesh(geometry, material);
                this.scene.add(beam);
                setTimeout(() => { this.scene.remove(beam); }, 500);
            }

            createEntanglementLink(ion1, ion2) {
                // A wavy line connecting two ions
                const curve = new THREE.CatmullRomCurve3([
                    ion1.position,
                    new THREE.Vector3((ion1.position.x + ion2.position.x)/2, 0.5, 0),
                    ion2.position
                ]);
                
                const points = curve.getPoints(50);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                const splineObject = new THREE.Line(geometry, material);
                
                this.scene.add(splineObject);
                
                // Animate removal or keep it? Let's remove after 1s for now
                setTimeout(() => { this.scene.remove(splineObject); }, 1000);
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const time = performance.now() * 0.001;

                // Idle Animation: Thermal vibration
                this.ions.forEach((ion, idx) => {
                    // Ions vibrate slightly out of phase
                    ion.position.y = ion.userData.basePosition.y + Math.sin(time * 5 + idx) * 0.05;
                    ion.position.z = ion.userData.basePosition.z + Math.cos(time * 4 + idx) * 0.05;
                });

                this.controls.update();
                // Use composer for bloom effect
                this.composer.render();
            }
        }

        // Initialize Application
        const app = new IonSimulator();
        // Make app global so HTML buttons can see it
        window.app = app; 
    </script>
</body>
</html>